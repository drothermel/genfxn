from genfxn.graph_queries.models import GraphQueriesSpec


def render_graph_queries(
    spec: GraphQueriesSpec,
    func_name: str = "f",
    src_var: str = "src",
    dst_var: str = "dst",
) -> str:
    lines = [
        f"public static long {func_name}(int {src_var}, int {dst_var}) {{",
        f"    int nNodes = {spec.n_nodes};",
        f"    boolean directed = {str(spec.directed).lower()};",
        f"    boolean weighted = {str(spec.weighted).lower()};",
        f'    String queryType = "{spec.query_type.value}";',
        "    int[][] edges = new int[][] {",
    ]

    for edge in spec.edges:
        lines.append(
            "        new int[] "
            + f"{{{edge.u}, {edge.v}, {edge.w}}},"
        )

    lines.extend(
        [
            "    };",
            "",
            f"    if ({src_var} < 0 || {src_var} >= nNodes) {{",
            "        throw new IllegalArgumentException(",
            f'            "src out of range: " + {src_var}',
            "        );",
            "    }",
            f"    if ({dst_var} < 0 || {dst_var} >= nNodes) {{",
            "        throw new IllegalArgumentException(",
            f'            "dst out of range: " + {dst_var}',
            "        );",
            "    }",
            "",
            f"    if ({src_var} == {dst_var}) {{",
            '        if (queryType.equals("reachable")) {',
            "            return 1;",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    java.util.HashMap<Long, Integer> best = "
            "new java.util.HashMap<>();",
            "    for (int[] edge : edges) {",
            "        int rawU = edge[0];",
            "        int rawV = edge[1];",
            "        int rawW = edge[2];",
            "        int weight = weighted ? rawW : 1;",
            "        long key = (((long) rawU) << 32) ^ "
            "(rawV & 0xFFFF_FFFFL);",
            "        Integer prev = best.get(key);",
            "        if (prev == null || weight < prev) {",
            "            best.put(key, weight);",
            "        }",
            "        if (!directed) {",
            "            long revKey = (((long) rawV) << 32) ^ "
            "(rawU & 0xFFFF_FFFFL);",
            "            Integer revPrev = best.get(revKey);",
            "            if (revPrev == null || weight < revPrev) {",
            "                best.put(revKey, weight);",
            "            }",
            "        }",
            "    }",
            "",
            "    java.util.ArrayList<int[]>[] adjacency = "
            "new java.util.ArrayList[nNodes];",
            "    for (int node = 0; node < nNodes; node++) {",
            "        adjacency[node] = new java.util.ArrayList<>();",
            "    }",
            "    for (java.util.Map.Entry<Long, Integer> entry : "
            "best.entrySet()) {",
            "        long key = entry.getKey();",
            "        int u = (int) (key >> 32);",
            "        int v = (int) key;",
            "        adjacency[u].add(new int[] {v, entry.getValue()});",
            "    }",
            "    for (java.util.ArrayList<int[]> neighbors : adjacency) {",
            "        neighbors.sort((left, right) -> {",
            "            int nodeCmp = Integer.compare(left[0], right[0]);",
            "            if (nodeCmp != 0) {",
            "                return nodeCmp;",
            "            }",
            "            return Integer.compare(left[1], right[1]);",
            "        });",
            "    }",
            "",
            '    if (queryType.equals("reachable")) {',
            "        java.util.HashSet<Integer> visited = "
            "new java.util.HashSet<>();",
            "        java.util.ArrayDeque<Integer> queue = "
            "new java.util.ArrayDeque<>();",
            f"        visited.add({src_var});",
            f"        queue.add({src_var});",
            "        while (!queue.isEmpty()) {",
            "            int node = queue.removeFirst();",
            f"            if (node == {dst_var}) {{",
            "                return 1;",
            "            }",
            "            for (int[] pair : adjacency[node]) {",
            "                int neighbor = pair[0];",
            "                if (visited.contains(neighbor)) {",
            "                    continue;",
            "                }",
            "                visited.add(neighbor);",
            "                queue.addLast(neighbor);",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            '    if (queryType.equals("min_hops")) {',
            "        java.util.HashSet<Integer> visited = "
            "new java.util.HashSet<>();",
            "        java.util.ArrayDeque<int[]> queue = "
            "new java.util.ArrayDeque<>();",
            f"        visited.add({src_var});",
            f"        queue.add(new int[] {{{src_var}, 0}});",
            "        while (!queue.isEmpty()) {",
            "            int[] item = queue.removeFirst();",
            "            int node = item[0];",
            "            int hops = item[1];",
            f"            if (node == {dst_var}) {{",
            "                return hops;",
            "            }",
            "            for (int[] pair : adjacency[node]) {",
            "                int neighbor = pair[0];",
            "                if (visited.contains(neighbor)) {",
            "                    continue;",
            "                }",
            "                visited.add(neighbor);",
            "                queue.addLast(new int[] {neighbor, hops + 1});",
            "            }",
            "        }",
            "        return -1;",
            "    }",
            "",
            "    java.util.HashMap<Integer, Long> bestCost = "
            "new java.util.HashMap<>();",
            "    java.util.ArrayList<Integer> frontier = "
            "new java.util.ArrayList<>();",
            f"    bestCost.put({src_var}, 0L);",
            f"    frontier.add({src_var});",
            "    while (!frontier.isEmpty()) {",
            "        int bestIdx = 0;",
            "        int bestNode = frontier.get(0);",
            "        long bestValue = bestCost.get(bestNode);",
            "        for (int i = 1; i < frontier.size(); i++) {",
            "            int candidateNode = frontier.get(i);",
            "            long candidateValue = bestCost.get(candidateNode);",
            "            if (candidateValue < bestValue || "
            "(candidateValue == bestValue && candidateNode < bestNode)) {",
            "                bestIdx = i;",
            "                bestNode = candidateNode;",
            "                bestValue = candidateValue;",
            "            }",
            "        }",
            "",
            "        int node = frontier.get(bestIdx);",
            "        long cost = bestCost.get(node);",
            "        int last = frontier.size() - 1;",
            "        frontier.set(bestIdx, frontier.get(last));",
            "        frontier.remove(last);",
            f"        if (node == {dst_var}) {{",
            "            return cost;",
            "        }",
            "        for (int[] pair : adjacency[node]) {",
            "            int neighbor = pair[0];",
            "            int weight = pair[1];",
            "            long nextCost = cost + (long) weight;",
            "            Long prev = bestCost.get(neighbor);",
            "            if (prev != null && nextCost >= prev) {",
            "                continue;",
            "            }",
            "            bestCost.put(neighbor, nextCost);",
            "            if (prev == null) {",
            "                frontier.add(neighbor);",
            "            }",
            "        }",
            "    }",
            "    return -1L;",
            "}",
        ]
    )
    return "\n".join(lines)
