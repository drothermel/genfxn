from genfxn.intervals.models import IntervalsSpec


def render_intervals(
    spec: IntervalsSpec,
    func_name: str = "f",
    var: str = "intervals",
) -> str:
    lines = [
        f"public static long {func_name}(long[][] {var}) {{",
        f'    String operation = "{spec.operation.value}";',
        f'    String boundaryMode = "{spec.boundary_mode.value}";',
        f"    boolean mergeTouching = {str(spec.merge_touching).lower()};",
        "",
        "    java.util.ArrayList<long[]> adjusted = "
        "new java.util.ArrayList<>();",
        f"    for (long[] raw : {var}) {{",
        "        long lo = Math.min(raw[0], raw[1]);",
        "        long hi = Math.max(raw[0], raw[1]);",
        "",
        "        long start;",
        "        long end;",
        '        if (boundaryMode.equals("closed_closed")) {',
        "            start = lo;",
        "            end = hi;",
        '        } else if (boundaryMode.equals("closed_open")) {',
        "            start = lo;",
        "            end = hi - 1L;",
        '        } else if (boundaryMode.equals("open_closed")) {',
        "            start = lo + 1L;",
        "            end = hi;",
        '        } else if (boundaryMode.equals("open_open")) {',
        "            start = lo + 1L;",
        "            end = hi - 1L;",
        "        } else {",
        "            throw new IllegalArgumentException(",
        '                "Unsupported boundary mode"',
        "            );",
        "        }",
        "",
        "        if (start <= end) {",
        "            adjusted.add(new long[] {start, end});",
        "        }",
        "    }",
        "",
        "    if (adjusted.isEmpty()) {",
        "        return 0L;",
        "    }",
        "",
        "    adjusted.sort((left, right) -> {",
        "        int startCmp = Long.compare(left[0], right[0]);",
        "        if (startCmp != 0) {",
        "            return startCmp;",
        "        }",
        "        return Long.compare(left[1], right[1]);",
        "    });",
        "",
        "    java.util.ArrayList<long[]> merged = new java.util.ArrayList<>();",
        "    long[] first = adjusted.get(0);",
        "    merged.add(new long[] {first[0], first[1]});",
        "    for (int idx = 1; idx < adjusted.size(); idx++) {",
        "        long[] span = adjusted.get(idx);",
        "        long[] prev = merged.get(merged.size() - 1);",
        "        long threshold = mergeTouching ? prev[1] + 1L : prev[1];",
        "        if (span[0] <= threshold) {",
        "            prev[1] = Math.max(prev[1], span[1]);",
        "        } else {",
        "            merged.add(new long[] {span[0], span[1]});",
        "        }",
        "    }",
        "",
        '    if (operation.equals("total_coverage")) {',
        "        long total = 0L;",
        "        for (long[] span : merged) {",
        "            total += span[1] - span[0] + 1L;",
        "        }",
        "        return total;",
        "    }",
        "",
        '    if (operation.equals("merged_count")) {',
        "        return merged.size();",
        "    }",
        "",
        '    if (operation.equals("gap_count")) {',
        "        long gaps = 0L;",
        "        for (int idx = 1; idx < merged.size(); idx++) {",
        "            long[] prev = merged.get(idx - 1);",
        "            long[] next = merged.get(idx);",
        "            if (next[0] > prev[1] + 1L) {",
        "                gaps += 1L;",
        "            }",
        "        }",
        "        return gaps;",
        "    }",
        "",
        '    if (operation.equals("max_overlap_count")) {',
        (
            "        java.util.TreeMap<Long, Long> events = "
            "new java.util.TreeMap<>();"
        ),
        "        for (long[] span : adjusted) {",
        "            long start = span[0];",
        "            long end = span[1] + 1L;",
        "            events.put(start, events.getOrDefault(start, 0L) + 1L);",
        "            events.put(end, events.getOrDefault(end, 0L) - 1L);",
        "        }",
        "",
        "        long active = 0L;",
        "        long best = 0L;",
        "        for (long delta : events.values()) {",
        "            active += delta;",
        "            if (active > best) {",
        "                best = active;",
        "            }",
        "        }",
        "        return best;",
        "    }",
        "",
        "    throw new IllegalArgumentException(",
        '        "Unsupported operation"',
        "    );",
        "}",
    ]
    return "\n".join(lines)
