from genfxn.stack_bytecode.models import StackBytecodeSpec


def render_stack_bytecode(
    spec: StackBytecodeSpec, func_name: str = "f", var: str = "xs"
) -> str:
    # Java renderer intentionally uses int[]/int arithmetic for idiomatic Java.
    # Rust uses i64; extremely large values can overflow differently per target.
    ops = ", ".join(f'"{instr.op.value}"' for instr in spec.program)
    values = ", ".join(
        str(instr.value if instr.value is not None else 0)
        for instr in spec.program
    )
    indices = ", ".join(
        str(instr.index if instr.index is not None else 0)
        for instr in spec.program
    )
    targets = ", ".join(
        str(instr.target if instr.target is not None else 0)
        for instr in spec.program
    )

    lines = [
        f"public static int[] {func_name}(int[] {var}) {{",
        "    String[] ops = new String[] {" + ops + "};",
        "    int[] values = new int[] {" + values + "};",
        "    int[] indices = new int[] {" + indices + "};",
        "    int[] targets = new int[] {" + targets + "};",
        f"    int maxStepCount = {spec.max_step_count};",
        f'    String jumpTargetMode = "{spec.jump_target_mode.value}";',
        f'    String inputMode = "{spec.input_mode.value}";',
        "",
        "    int[] stack = new int[maxStepCount + ops.length + 8];",
        "    int sp = 0;",
        "    int pc = 0;",
        "    int steps = 0;",
        "",
        "    while (steps < maxStepCount) {",
        "        if (pc < 0 || pc >= ops.length) {",
        "            return new int[] {3, 0};",
        "        }",
        "",
        "        String op = ops[pc];",
        "        steps += 1;",
        "",
        '        if (op.equals("push_const")) {',
        "            stack[sp] = values[pc];",
        "            sp += 1;",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("load_input")) {',
        "            int idx = indices[pc];",
        '            if (inputMode.equals("direct")) {',
        f"                if (idx < 0 || idx >= {var}.length) {{",
        "                    return new int[] {5, 0};",
        "                }",
        f"                stack[sp] = {var}[idx];",
        "            } else {",
        f"                if ({var}.length == 0) {{",
        "                    return new int[] {5, 0};",
        "                }",
        f"                int m = idx % {var}.length;",
        f"                if (m < 0) m += {var}.length;",
        f"                stack[sp] = {var}[m];",
        "            }",
        "            sp += 1;",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("dup")) {',
        "            if (sp < 1) return new int[] {2, 0};",
        "            int a = stack[sp - 1];",
        "            stack[sp] = a;",
        "            sp += 1;",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("swap")) {',
        "            if (sp < 2) return new int[] {2, 0};",
        "            int a = stack[sp - 1];",
        "            stack[sp - 1] = stack[sp - 2];",
        "            stack[sp - 2] = a;",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("pop")) {',
        "            if (sp < 1) return new int[] {2, 0};",
        "            sp -= 1;",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("add") || op.equals("sub") ||',
        '            op.equals("mul") || op.equals("div") ||',
        '            op.equals("mod") || op.equals("eq") ||',
        '            op.equals("gt") || op.equals("lt")) {',
        "            if (sp < 2) return new int[] {2, 0};",
        "            int b = stack[sp - 1];",
        "            int a = stack[sp - 2];",
        "            sp -= 2;",
        "            int out;",
        '            if (op.equals("add")) out = a + b;',
        '            else if (op.equals("sub")) out = a - b;',
        '            else if (op.equals("mul")) out = a * b;',
        '            else if (op.equals("div")) {',
        "                if (b == 0) return new int[] {4, 0};",
        "                out = a / b;",
        '            } else if (op.equals("mod")) {',
        "                if (b == 0) return new int[] {4, 0};",
        "                out = a % b;",
        '            } else if (op.equals("eq")) out = (a == b) ? 1 : 0;',
        '            else if (op.equals("gt")) out = (a > b) ? 1 : 0;',
        "            else out = (a < b) ? 1 : 0;",
        "            stack[sp] = out;",
        "            sp += 1;",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("neg")) {',
        "            if (sp < 1) return new int[] {2, 0};",
        "            stack[sp - 1] = -stack[sp - 1];",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("abs")) {',
        "            if (sp < 1) return new int[] {2, 0};",
        "            stack[sp - 1] = Math.abs(stack[sp - 1]);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("is_zero")) {',
        "            if (sp < 1) return new int[] {2, 0};",
        "            stack[sp - 1] = (stack[sp - 1] == 0) ? 1 : 0;",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("jump") || op.equals("jump_if_zero") ||',
        '            op.equals("jump_if_nonzero")) {',
        "            boolean cond;",
        '            if (op.equals("jump")) {',
        "                cond = true;",
        "            } else {",
        "                if (sp < 1) return new int[] {2, 0};",
        "                int a = stack[sp - 1];",
        "                sp -= 1;",
        '                cond = op.equals("jump_if_zero")',
        "                    ? (a == 0) : (a != 0);",
        "            }",
        "",
        "            if (cond) {",
        "                int target = targets[pc];",
        "                int resolved;",
        '                if (jumpTargetMode.equals("error")) {',
        "                    if (target < 0 || target >= ops.length) {",
        "                        return new int[] {3, 0};",
        "                    }",
        "                    resolved = target;",
        '                } else if (jumpTargetMode.equals("clamp")) {',
        "                    if (target < 0) resolved = 0;",
        "                    else if (target >= ops.length)",
        "                        resolved = ops.length - 1;",
        "                    else resolved = target;",
        "                } else {",
        "                    resolved = target % ops.length;",
        "                    if (resolved < 0) resolved += ops.length;",
        "                }",
        "                pc = resolved;",
        "            } else {",
        "                pc += 1;",
        "            }",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("halt")) {',
        "            if (sp < 1) return new int[] {6, 0};",
        "            return new int[] {0, stack[sp - 1]};",
        "        }",
        "",
        "        return new int[] {3, 0};",
        "    }",
        "",
        "    return new int[] {1, 0};",
        "}",
    ]
    return "\n".join(lines)
