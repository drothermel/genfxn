from genfxn.langs.java._helpers import java_long_literal
from genfxn.stack_bytecode.models import StackBytecodeSpec


def render_stack_bytecode(
    spec: StackBytecodeSpec, func_name: str = "f", var: str = "xs"
) -> str:
    ops = ", ".join(f'"{instr.op.value}"' for instr in spec.program)
    values = ", ".join(
        java_long_literal(instr.value if instr.value is not None else 0)
        for instr in spec.program
    )
    indices = ", ".join(
        java_long_literal(instr.index if instr.index is not None else 0)
        for instr in spec.program
    )
    targets = ", ".join(
        java_long_literal(instr.target if instr.target is not None else 0)
        for instr in spec.program
    )

    lines = [
        f"public static long[] {func_name}(long[] {var}) {{",
        "    String[] ops = new String[] {" + ops + "};",
        "    long[] values = new long[] {" + values + "};",
        "    long[] indices = new long[] {" + indices + "};",
        "    long[] targets = new long[] {" + targets + "};",
        f"    long maxStepCount = {java_long_literal(spec.max_step_count)};",
        f'    String jumpTargetMode = "{spec.jump_target_mode.value}";',
        f'    String inputMode = "{spec.input_mode.value}";',
        "",
        "    java.util.ArrayList<Long> stack = new java.util.ArrayList<>();",
        "    int pc = 0;",
        "    long steps = 0L;",
        "",
        "    while (steps < maxStepCount) {",
        "        if (pc < 0 || pc >= ops.length) {",
        "            return new long[] {3L, 0L};",
        "        }",
        "",
        "        String op = ops[pc];",
        "        steps += 1L;",
        "",
        '        if (op.equals("push_const")) {',
        "            stack.add(values[pc]);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("load_input")) {',
        "            long idx = indices[pc];",
        '            if (inputMode.equals("direct")) {',
        f"                if (idx < 0 || idx >= {var}.length) {{",
        "                    return new long[] {5L, 0L};",
        "                }",
        f"                stack.add({var}[(int) idx]);",
        "            } else {",
        f"                if ({var}.length == 0) {{",
        "                    return new long[] {5L, 0L};",
        "                }",
        f"                long m = Math.floorMod(idx, (long) {var}.length);",
        f"                stack.add({var}[(int) m]);",
        "            }",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("dup")) {',
        "            if (stack.size() < 1) return new long[] {2L, 0L};",
        "            long a = stack.get(stack.size() - 1);",
        "            stack.add(a);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("swap")) {',
        "            if (stack.size() < 2) return new long[] {2L, 0L};",
        "            int top = stack.size() - 1;",
        "            long a = stack.get(top);",
        "            stack.set(top, stack.get(top - 1));",
        "            stack.set(top - 1, a);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("pop")) {',
        "            if (stack.size() < 1) return new long[] {2L, 0L};",
        "            stack.remove(stack.size() - 1);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("add") || op.equals("sub") ||',
        '            op.equals("mul") || op.equals("div") ||',
        '            op.equals("mod") || op.equals("eq") ||',
        '            op.equals("gt") || op.equals("lt")) {',
        "            if (stack.size() < 2) return new long[] {2L, 0L};",
        "            long b = stack.remove(stack.size() - 1);",
        "            long a = stack.remove(stack.size() - 1);",
        "            long out;",
        '            if (op.equals("add")) out = a + b;',
        '            else if (op.equals("sub")) out = a - b;',
        '            else if (op.equals("mul")) out = a * b;',
        '            else if (op.equals("div")) {',
        "                if (b == 0L) return new long[] {4L, 0L};",
        "                out = a / b;",
        '            } else if (op.equals("mod")) {',
        "                if (b == 0L) return new long[] {4L, 0L};",
        "                out = a % b;",
        '            } else if (op.equals("eq")) out = (a == b) ? 1L : 0L;',
        '            else if (op.equals("gt")) out = (a > b) ? 1L : 0L;',
        "            else out = (a < b) ? 1L : 0L;",
        "            stack.add(out);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("neg")) {',
        "            if (stack.size() < 1) return new long[] {2L, 0L};",
        "            int top = stack.size() - 1;",
        "            stack.set(top, -stack.get(top));",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("abs")) {',
        "            if (stack.size() < 1) return new long[] {2L, 0L};",
        "            int top = stack.size() - 1;",
        "            stack.set(top, Math.abs(stack.get(top)));",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("is_zero")) {',
        "            if (stack.size() < 1) return new long[] {2L, 0L};",
        "            int top = stack.size() - 1;",
        "            stack.set(top, stack.get(top) == 0L ? 1L : 0L);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("jump") || op.equals("jump_if_zero") ||',
        '            op.equals("jump_if_nonzero")) {',
        "            boolean cond;",
        '            if (op.equals("jump")) {',
        "                cond = true;",
        "            } else {",
        "                if (stack.size() < 1) return new long[] {2L, 0L};",
        "                long a = stack.remove(stack.size() - 1);",
        '                cond = op.equals("jump_if_zero")',
        "                    ? (a == 0L) : (a != 0L);",
        "            }",
        "",
        "            if (cond) {",
        "                long target = targets[pc];",
        "                int resolved;",
        '                if (jumpTargetMode.equals("error")) {',
        "                    if (target < 0 || target >= ops.length) {",
        "                        return new long[] {3L, 0L};",
        "                    }",
        "                    resolved = (int) target;",
        '                } else if (jumpTargetMode.equals("clamp")) {',
        "                    if (target < 0) resolved = 0;",
        "                    else if (target >= ops.length)",
        "                        resolved = ops.length - 1;",
        "                    else resolved = (int) target;",
        "                } else {",
        "                    resolved = (int) Math.floorMod(target, "
        "(long) ops.length);",
        "                }",
        "                pc = resolved;",
        "            } else {",
        "                pc += 1;",
        "            }",
        "            continue;",
        "        }",
        "",
        '        if (op.equals("halt")) {',
        "            if (stack.size() < 1) return new long[] {6L, 0L};",
        "            return new long[] {0L, stack.get(stack.size() - 1)};",
        "        }",
        "",
        "        return new long[] {3L, 0L};",
        "    }",
        "",
        "    return new long[] {1L, 0L};",
        "}",
    ]
    return "\n".join(lines)
