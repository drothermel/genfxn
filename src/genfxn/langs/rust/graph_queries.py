from genfxn.graph_queries.models import GraphQueriesSpec


def render_graph_queries(
    spec: GraphQueriesSpec,
    func_name: str = "f",
    src_var: str = "src",
    dst_var: str = "dst",
) -> str:
    lines = [
        f"fn {func_name}({src_var}: i64, {dst_var}: i64) -> i64 {{",
        f"    let n_nodes: usize = {spec.n_nodes};",
        f"    let directed = {str(spec.directed).lower()};",
        f"    let weighted = {str(spec.weighted).lower()};",
        f'    let query_type = "{spec.query_type.value}";',
        "    let edges: Vec<(i64, i64, i64)> = vec![",
    ]

    for edge in spec.edges:
        lines.append(f"        ({edge.u}, {edge.v}, {edge.w}),")

    lines.extend(
        [
            "    ];",
            "",
            f"    if {src_var} < 0 || {src_var} >= n_nodes as i64 {{",
            f'        panic!("src out of range: {{}}", {src_var});',
            "    }",
            f"    if {dst_var} < 0 || {dst_var} >= n_nodes as i64 {{",
            f'        panic!("dst out of range: {{}}", {dst_var});',
            "    }",
            "",
            f"    if {src_var} == {dst_var} {{",
            "        if query_type == \"reachable\" {",
            "            return 1;",
            "        }",
            "        return 0;",
            "    }",
            "",
            f"    let src_idx = {src_var} as usize;",
            f"    let dst_idx = {dst_var} as usize;",
            "",
            "    let mut best = "
            "std::collections::HashMap::<(usize, usize), i64>::new();",
            "    for &(raw_u_i64, raw_v_i64, raw_w) in &edges {",
            "        if raw_u_i64 < 0 || raw_u_i64 >= n_nodes as i64 || "
            "raw_v_i64 < 0 || raw_v_i64 >= n_nodes as i64 {",
            '            panic!("edge endpoint out of range for '
            'n_nodes={}", n_nodes);',
            "        }",
            "        let raw_u = raw_u_i64 as usize;",
            "        let raw_v = raw_v_i64 as usize;",
            "        let weight = if weighted { raw_w } else { 1 };",
            "        let key = (raw_u, raw_v);",
            "        match best.get(&key) {",
            "            Some(prev) if *prev <= weight => {}",
            "            _ => {",
            "                best.insert(key, weight);",
            "            }",
            "        }",
            "        if !directed {",
            "            let rev_key = (raw_v, raw_u);",
            "            match best.get(&rev_key) {",
            "                Some(prev) if *prev <= weight => {}",
            "                _ => {",
            "                    best.insert(rev_key, weight);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    let mut adjacency: Vec<Vec<(usize, i64)>> = "
            "vec![Vec::new(); n_nodes];",
            "    for ((u, v), weight) in best {",
            "        adjacency[u].push((v, weight));",
            "    }",
            "    for neighbors in &mut adjacency {",
            "        neighbors.sort_unstable();",
            "    }",
            "",
            "    if query_type == \"reachable\" {",
            "        let mut visited = vec![false; n_nodes];",
            "        let mut queue: Vec<usize> = vec![src_idx];",
            "        let mut head = 0usize;",
            "        visited[src_idx] = true;",
            "        while head < queue.len() {",
            "            let node = queue[head];",
            "            head += 1;",
            "            if node == dst_idx {",
            "                return 1;",
            "            }",
            "            for &(neighbor, _) in &adjacency[node] {",
            "                if visited[neighbor] {",
            "                    continue;",
            "                }",
            "                visited[neighbor] = true;",
            "                queue.push(neighbor);",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    if query_type == \"min_hops\" {",
            "        let mut visited = vec![false; n_nodes];",
            "        let mut queue: Vec<(usize, i64)> = vec![(src_idx, 0)];",
            "        let mut head = 0usize;",
            "        visited[src_idx] = true;",
            "        while head < queue.len() {",
            "            let (node, hops) = queue[head];",
            "            head += 1;",
            "            if node == dst_idx {",
            "                return hops;",
            "            }",
            "            for &(neighbor, _) in &adjacency[node] {",
            "                if visited[neighbor] {",
            "                    continue;",
            "                }",
            "                visited[neighbor] = true;",
            "                queue.push((neighbor, hops + 1));",
            "            }",
            "        }",
            "        return -1;",
            "    }",
            "",
            (
                "    let mut best_cost_prev: Vec<Option<i64>> = "
                "vec![None; n_nodes];"
            ),
            "    best_cost_prev[src_idx] = Some(0);",
            "    for _iter in 0..n_nodes.saturating_sub(1) {",
            "        let mut changed = false;",
            "        let mut best_cost_curr = best_cost_prev.clone();",
            "        for node in 0..n_nodes {",
            "            let Some(cost) = best_cost_prev[node] else {",
            "                continue;",
            "            };",
            "            for &(neighbor, weight) in &adjacency[node] {",
            "                let next_cost = if cost > i64::MAX - weight {",
            "                    i64::MAX",
            "                } else {",
            "                    cost + weight",
            "                };",
            "                if let Some(prev) = best_cost_curr[neighbor] {",
            "                    if next_cost >= prev {",
            "                        continue;",
            "                    }",
            "                }",
            "                best_cost_curr[neighbor] = Some(next_cost);",
            "                changed = true;",
            "            }",
            "        }",
            "        best_cost_prev = best_cost_curr;",
            "        if !changed {",
            "            break;",
            "        }",
            "    }",
            "    best_cost_prev[dst_idx].unwrap_or(-1)",
            "}",
        ]
    )
    return "\n".join(lines)
