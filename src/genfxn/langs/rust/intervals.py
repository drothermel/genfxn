from genfxn.intervals.models import IntervalsSpec
from genfxn.langs.rust._helpers import rust_i64_literal


def render_intervals(
    spec: IntervalsSpec,
    func_name: str = "f",
    var: str = "intervals",
) -> str:
    lines = [
        f"fn {func_name}({var}: &[(i64, i64)]) -> i64 {{",
        f'    let operation = "{spec.operation.value}";',
        f'    let boundary_mode = "{spec.boundary_mode.value}";',
        f"    let merge_touching = {str(spec.merge_touching).lower()};",
        (
            "    let endpoint_clip_abs: i64 = "
            f"{rust_i64_literal(spec.endpoint_clip_abs)};"
        ),
        (
            "    let endpoint_quantize_step: i64 = "
            f"{rust_i64_literal(spec.endpoint_quantize_step)};"
        ),
        "",
        "    let mut adjusted: Vec<(i64, i64)> = Vec::new();",
        f"    for &(raw_a, raw_b) in {var} {{",
        "        let mut a = raw_a.min(endpoint_clip_abs);",
        "        a = a.max(-endpoint_clip_abs);",
        "        let mut b = raw_b.min(endpoint_clip_abs);",
        "        b = b.max(-endpoint_clip_abs);",
        "        if endpoint_quantize_step > 1 {",
        "            let qa_mag = a.abs() / endpoint_quantize_step;",
        "            let qb_mag = b.abs() / endpoint_quantize_step;",
        "            let qa = qa_mag * endpoint_quantize_step;",
        "            let qb = qb_mag * endpoint_quantize_step;",
        "            a = if a >= 0 { qa } else { -qa };",
        "            b = if b >= 0 { qb } else { -qb };",
        "        }",
        "        let lo = a.min(b);",
        "        let hi = a.max(b);",
        "",
        "        let (start, end) = if boundary_mode == \"closed_closed\" {",
        "            (lo, hi)",
        "        } else if boundary_mode == \"closed_open\" {",
        "            (lo, hi.wrapping_sub(1))",
        "        } else if boundary_mode == \"open_closed\" {",
        "            (lo.wrapping_add(1), hi)",
        "        } else if boundary_mode == \"open_open\" {",
        "            (lo.wrapping_add(1), hi.wrapping_sub(1))",
        "        } else {",
        "            panic!(\"Unsupported boundary mode\");",
        "        };",
        "",
        "        if start <= end {",
        "            adjusted.push((start, end));",
        "        }",
        "    }",
        "",
        "    if adjusted.is_empty() {",
        "        return 0;",
        "    }",
        "",
        "    adjusted.sort_unstable();",
        "    let mut merged: Vec<(i64, i64)> = vec![adjusted[0]];",
        "    for &(start, end) in adjusted.iter().skip(1) {",
        "        let last_idx = merged.len() - 1;",
        "        let (prev_start, prev_end) = merged[last_idx];",
        "        let threshold = if merge_touching {",
        "            prev_end.wrapping_add(1)",
        "        } else {",
        "            prev_end",
        "        };",
        "        if start <= threshold {",
        "            merged[last_idx] = (prev_start, prev_end.max(end));",
        "        } else {",
        "            merged.push((start, end));",
        "        }",
        "    }",
        "",
        "    if operation == \"total_coverage\" {",
        "        let mut total: i64 = 0;",
        "        for &(start, end) in &merged {",
        (
            "            total = total.wrapping_add("
            "end.wrapping_sub(start).wrapping_add(1));"
        ),
        "        }",
        "        return total;",
        "    }",
        "",
        "    if operation == \"merged_count\" {",
        "        return merged.len() as i64;",
        "    }",
        "",
        "    if operation == \"gap_count\" {",
        "        let mut gaps: i64 = 0;",
        "        for idx in 1..merged.len() {",
        "            let prev_end = merged[idx - 1].1;",
        "            let next_start = merged[idx].0;",
        "            if next_start > prev_end.wrapping_add(1) {",
        "                gaps += 1;",
        "            }",
        "        }",
        "        return gaps;",
        "    }",
        "",
        "    if operation == \"max_overlap_count\" {",
        (
            "        let mut events: std::collections::BTreeMap<i64, i64> = "
            "std::collections::BTreeMap::new();"
        ),
        "        for &(start, end) in &adjusted {",
        "            *events.entry(start).or_insert(0) += 1;",
        (
            "            *events.entry(end.wrapping_add(1)).or_insert(0) -= 1;"
        ),
        "        }",
        "",
        "        let mut active: i64 = 0;",
        "        let mut best: i64 = 0;",
        "        for delta in events.values() {",
        "            active = active.wrapping_add(*delta);",
        "            if active > best {",
        "                best = active;",
        "            }",
        "        }",
        "        return best;",
        "    }",
        "",
        "    panic!(\"Unsupported operation\");",
        "}",
    ]
    return "\n".join(lines)
