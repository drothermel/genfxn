from genfxn.intervals.models import IntervalsSpec


def render_intervals(
    spec: IntervalsSpec,
    func_name: str = "f",
    var: str = "intervals",
) -> str:
    lines = [
        f"fn {func_name}({var}: &[(i64, i64)]) -> i64 {{",
        f'    let operation = "{spec.operation.value}";',
        f'    let boundary_mode = "{spec.boundary_mode.value}";',
        f"    let merge_touching = {str(spec.merge_touching).lower()};",
        "",
        "    let mut adjusted: Vec<(i64, i64)> = Vec::new();",
        f"    for &(raw_a, raw_b) in {var} {{",
        "        let lo = raw_a.min(raw_b);",
        "        let hi = raw_a.max(raw_b);",
        "",
        "        let (start, end) = if boundary_mode == \"closed_closed\" {",
        "            (lo, hi)",
        "        } else if boundary_mode == \"closed_open\" {",
        "            (lo, hi - 1)",
        "        } else if boundary_mode == \"open_closed\" {",
        "            (lo + 1, hi)",
        "        } else if boundary_mode == \"open_open\" {",
        "            (lo + 1, hi - 1)",
        "        } else {",
        "            panic!(\"Unsupported boundary mode\");",
        "        };",
        "",
        "        if start <= end {",
        "            adjusted.push((start, end));",
        "        }",
        "    }",
        "",
        "    if adjusted.is_empty() {",
        "        return 0;",
        "    }",
        "",
        "    adjusted.sort_unstable();",
        "    let mut merged: Vec<(i64, i64)> = vec![adjusted[0]];",
        "    for &(start, end) in adjusted.iter().skip(1) {",
        "        let (prev_start, prev_end) = merged[merged.len() - 1];",
        "        let threshold = if merge_touching {",
        "            prev_end + 1",
        "        } else {",
        "            prev_end",
        "        };",
        "        if start <= threshold {",
        (
            "            merged[merged.len() - 1] = "
            "(prev_start, prev_end.max(end));"
        ),
        "        } else {",
        "            merged.push((start, end));",
        "        }",
        "    }",
        "",
        "    if operation == \"total_coverage\" {",
        "        let mut total: i64 = 0;",
        "        for &(start, end) in &merged {",
        "            total += end - start + 1;",
        "        }",
        "        return total;",
        "    }",
        "",
        "    if operation == \"merged_count\" {",
        "        return merged.len() as i64;",
        "    }",
        "",
        "    if operation == \"gap_count\" {",
        "        let mut gaps: i64 = 0;",
        "        for idx in 1..merged.len() {",
        "            let prev_end = merged[idx - 1].1;",
        "            let next_start = merged[idx].0;",
        "            if next_start > prev_end + 1 {",
        "                gaps += 1;",
        "            }",
        "        }",
        "        return gaps;",
        "    }",
        "",
        "    if operation == \"max_overlap_count\" {",
        (
            "        let mut events: std::collections::BTreeMap<i64, i64> = "
            "std::collections::BTreeMap::new();"
        ),
        "        for &(start, end) in &adjusted {",
        "            *events.entry(start).or_insert(0) += 1;",
        "            *events.entry(end + 1).or_insert(0) -= 1;",
        "        }",
        "",
        "        let mut active: i64 = 0;",
        "        let mut best: i64 = 0;",
        "        for delta in events.values() {",
        "            active += *delta;",
        "            if active > best {",
        "                best = active;",
        "            }",
        "        }",
        "        return best;",
        "    }",
        "",
        "    panic!(\"Unsupported operation\");",
        "}",
    ]
    return "\n".join(lines)
