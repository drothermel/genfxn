from genfxn.stack_bytecode.models import StackBytecodeSpec


def render_stack_bytecode(
    spec: StackBytecodeSpec, func_name: str = "f", var: str = "xs"
) -> str:
    ops = ", ".join(f'"{instr.op.value}"' for instr in spec.program)
    values = ", ".join(
        str(instr.value if instr.value is not None else 0)
        for instr in spec.program
    )
    indices = ", ".join(
        str(instr.index if instr.index is not None else 0)
        for instr in spec.program
    )
    targets = ", ".join(
        str(instr.target if instr.target is not None else 0)
        for instr in spec.program
    )

    lines = [
        f"fn {func_name}({var}: &[i64]) -> (i64, i64) {{",
        "    let ops: [&str; " + str(len(spec.program)) + "] = [" + ops + "];",
        "    let values: [i64; "
        + str(len(spec.program))
        + "] = ["
        + values
        + "];",
        "    let indices: [i64; "
        + str(len(spec.program))
        + "] = ["
        + indices
        + "];",
        "    let targets: [i64; "
        + str(len(spec.program))
        + "] = ["
        + targets
        + "];",
        f"    let max_step_count: i64 = {spec.max_step_count};",
        f'    let jump_target_mode = "{spec.jump_target_mode.value}";',
        f'    let input_mode = "{spec.input_mode.value}";',
        "",
        "    let mut stack: Vec<i64> = Vec::new();",
        "    let mut pc: i64 = 0;",
        "    let mut steps: i64 = 0;",
        "    let n: i64 = ops.len() as i64;",
        "",
        "    fn java_div(a: i64, b: i64) -> Option<i64> {",
        "        if b == 0 {",
        "            return None;",
        "        }",
        "        if a == i64::MIN && b == -1 {",
        "            return Some(i64::MIN);",
        "        }",
        "        Some(a / b)",
        "    }",
        "",
        "    fn java_mod(a: i64, b: i64) -> Option<i64> {",
        "        if b == 0 {",
        "            return None;",
        "        }",
        "        if a == i64::MIN && b == -1 {",
        "            return Some(0);",
        "        }",
        "        Some(a % b)",
        "    }",
        "",
        "    while steps < max_step_count {",
        "        if pc < 0 || pc >= n {",
        "            return (3, 0);",
        "        }",
        "",
        "        let i = pc as usize;",
        "        let op = ops[i];",
        "        steps += 1;",
        "",
        '        if op == "push_const" {',
        "            stack.push(values[i]);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if op == "load_input" {',
        "            let idx = indices[i];",
        '            if input_mode == "direct" {',
        "                if idx < 0 || idx >= " + var + ".len() as i64 {",
        "                    return (5, 0);",
        "                }",
        "                stack.push(" + var + "[idx as usize]);",
        "            } else {",
        "                if " + var + ".is_empty() {",
        "                    return (5, 0);",
        "                }",
        "                let m = idx.rem_euclid("
        + var
        + ".len() as i64) as usize;",
        "                stack.push(" + var + "[m]);",
        "            }",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if op == "dup" {',
        "            let a = match stack.last() {",
        "                Some(v) => *v,",
        "                None => return (2, 0),",
        "            };",
        "            stack.push(a);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if op == "swap" {',
        "            if stack.len() < 2 {",
        "                return (2, 0);",
        "            }",
        "            let len = stack.len();",
        "            stack.swap(len - 1, len - 2);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if op == "pop" {',
        "            if stack.pop().is_none() {",
        "                return (2, 0);",
        "            }",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if op == "add" || op == "sub" || op == "mul" ||',
        '           op == "div" || op == "mod" || op == "eq" ||',
        '           op == "gt" || op == "lt" {',
        "            if stack.len() < 2 {",
        "                return (2, 0);",
        "            }",
        "            let b = stack.pop().unwrap_or(0);",
        "            let a = stack.pop().unwrap_or(0);",
        '            let out = if op == "add" {',
        "                a.wrapping_add(b)",
        '            } else if op == "sub" {',
        "                a.wrapping_sub(b)",
        '            } else if op == "mul" {',
        "                a.wrapping_mul(b)",
        '            } else if op == "div" {',
        "                match java_div(a, b) {",
        "                    Some(v) => v,",
        "                    None => return (4, 0),",
        "                }",
        '            } else if op == "mod" {',
        "                match java_mod(a, b) {",
        "                    Some(v) => v,",
        "                    None => return (4, 0),",
        "                }",
        '            } else if op == "eq" {',
        "                if a == b { 1 } else { 0 }",
        '            } else if op == "gt" {',
        "                if a > b { 1 } else { 0 }",
        "            } else {",
        "                if a < b { 1 } else { 0 }",
        "            };",
        "            stack.push(out);",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if op == "neg" {',
        "            let a = match stack.pop() {",
        "                Some(v) => v,",
        "                None => return (2, 0),",
        "            };",
        "            stack.push(a.wrapping_neg());",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if op == "abs" {',
        "            let a = match stack.pop() {",
        "                Some(v) => v,",
        "                None => return (2, 0),",
        "            };",
        (
            "            stack.push(if a == i64::MIN { i64::MIN } "
            "else { a.abs() });"
        ),
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if op == "is_zero" {',
        "            let a = match stack.pop() {",
        "                Some(v) => v,",
        "                None => return (2, 0),",
        "            };",
        "            stack.push(if a == 0 { 1 } else { 0 });",
        "            pc += 1;",
        "            continue;",
        "        }",
        "",
        '        if op == "jump" || op == "jump_if_zero" ||',
        '           op == "jump_if_nonzero" {',
        '            let cond = if op == "jump" {',
        "                true",
        "            } else {",
        "                let a = match stack.pop() {",
        "                    Some(v) => v,",
        "                    None => return (2, 0),",
        "                };",
        '                if op == "jump_if_zero" { a == 0 } else { a != 0 }',
        "            };",
        "",
        "            if cond {",
        "                let target = targets[i];",
        '                let resolved = if jump_target_mode == "error" {',
        "                    if target < 0 || target >= n {",
        "                        return (3, 0);",
        "                    }",
        "                    target",
        '                } else if jump_target_mode == "clamp" {',
        "                    if target < 0 {",
        "                        0",
        "                    } else if target >= n {",
        "                        n - 1",
        "                    } else {",
        "                        target",
        "                    }",
        "                } else {",
        "                    target.rem_euclid(n)",
        "                };",
        "                pc = resolved;",
        "            } else {",
        "                pc += 1;",
        "            }",
        "            continue;",
        "        }",
        "",
        '        if op == "halt" {',
        "            let v = match stack.last() {",
        "                Some(value) => *value,",
        "                None => return (6, 0),",
        "            };",
        "            return (0, v);",
        "        }",
        "",
        "        return (3, 0);",
        "    }",
        "",
        "    (1, 0)",
        "}",
    ]
    return "\n".join(lines)
