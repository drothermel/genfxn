from genfxn.sequence_dp.models import SequenceDpSpec, TieBreakOrder

_TIE_BREAK_MOVES: dict[TieBreakOrder, tuple[str, str, str]] = {
    TieBreakOrder.DIAG_UP_LEFT: ("diag", "up", "left"),
    TieBreakOrder.DIAG_LEFT_UP: ("diag", "left", "up"),
    TieBreakOrder.UP_DIAG_LEFT: ("up", "diag", "left"),
    TieBreakOrder.UP_LEFT_DIAG: ("up", "left", "diag"),
    TieBreakOrder.LEFT_DIAG_UP: ("left", "diag", "up"),
    TieBreakOrder.LEFT_UP_DIAG: ("left", "up", "diag"),
}


def render_sequence_dp(
    spec: SequenceDpSpec,
    func_name: str = "f",
    a_var: str = "a",
    b_var: str = "b",
) -> str:
    tie_break = _TIE_BREAK_MOVES[spec.step_tie_break]
    predicate = spec.match_predicate.model_dump()

    lines = [
        f"def {func_name}({a_var}: list[int], {b_var}: list[int]) -> int:",
        f"    template = {spec.template.value!r}",
        f"    output_mode = {spec.output_mode.value!r}",
        f"    predicate = {predicate!r}",
        f"    match_score = {spec.match_score}",
        f"    mismatch_score = {spec.mismatch_score}",
        f"    gap_score = {spec.gap_score}",
        f"    tie_order = {tie_break!r}",
        "",
        "    def _matches(x: int, y: int) -> bool:",
        "        kind = predicate['kind']",
        "        if kind == 'eq':",
        "            return x == y",
        "        if kind == 'abs_diff_le':",
        "            return abs(x - y) <= predicate['max_diff']",
        (
            "        return (x - y) % predicate['divisor'] == "
            "predicate['remainder']"
        ),
        "",
        "    def _pick(diag, up, left):",
        "        options = {'diag': diag, 'up': up, 'left': left}",
        "        best_score = max(diag[0], up[0], left[0])",
        "        for move in tie_order:",
        "            candidate = options[move]",
        "            if candidate[0] == best_score:",
        "                return candidate",
        "        raise RuntimeError('unreachable tie-break state')",
        "",
        f"    n = len({a_var})",
        f"    m = len({b_var})",
        "    zero = (0, 0, 0)  # (score, alignment_len, gap_count)",
        "    dp = [[zero for _ in range(m + 1)] for _ in range(n + 1)]",
        "",
        "    if template == 'global':",
        "        for i in range(1, n + 1):",
        "            s, l, g = dp[i - 1][0]",
        "            dp[i][0] = (s + gap_score, l + 1, g + 1)",
        "        for j in range(1, m + 1):",
        "            s, l, g = dp[0][j - 1]",
        "            dp[0][j] = (s + gap_score, l + 1, g + 1)",
        "",
        "    best = zero",
        "    for i in range(1, n + 1):",
        "        for j in range(1, m + 1):",
        "            ai = i - 1",
        "            bj = j - 1",
        "            prev_s, prev_l, prev_g = dp[i - 1][j - 1]",
        "            delta = match_score if _matches(",
        f"                {a_var}[ai], {b_var}[bj]",
        "            ) else mismatch_score",
        "            diag = (prev_s + delta, prev_l + 1, prev_g)",
        "",
        "            up_s, up_l, up_g = dp[i - 1][j]",
        "            up = (up_s + gap_score, up_l + 1, up_g + 1)",
        "",
        "            left_s, left_l, left_g = dp[i][j - 1]",
        "            left = (left_s + gap_score, left_l + 1, left_g + 1)",
        "",
        "            chosen = _pick(diag, up, left)",
        "            if template == 'local' and chosen[0] <= 0:",
        "                chosen = zero",
        "            dp[i][j] = chosen",
        "",
        "            if template == 'local' and chosen[0] > best[0]:",
        "                best = chosen",
        "",
        "    if template == 'global':",
        "        result = dp[n][m]",
        "    else:",
        "        result = best",
        "",
        "    if output_mode == 'score':",
        "        return result[0]",
        "    if output_mode == 'alignment_len':",
        "        return result[1]",
        "    return result[2]",
    ]
    return "\n".join(lines)
