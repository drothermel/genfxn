from genfxn.sequence_dp.models import SequenceDpSpec, TieBreakOrder

_TIE_BREAK_MOVES: dict[TieBreakOrder, tuple[str, str, str]] = {
    TieBreakOrder.DIAG_UP_LEFT: ("diag", "up", "left"),
    TieBreakOrder.DIAG_LEFT_UP: ("diag", "left", "up"),
    TieBreakOrder.UP_DIAG_LEFT: ("up", "diag", "left"),
    TieBreakOrder.UP_LEFT_DIAG: ("up", "left", "diag"),
    TieBreakOrder.LEFT_DIAG_UP: ("left", "diag", "up"),
    TieBreakOrder.LEFT_UP_DIAG: ("left", "up", "diag"),
}


def render_sequence_dp(
    spec: SequenceDpSpec,
    func_name: str = "f",
    a_var: str = "a",
    b_var: str = "b",
) -> str:
    tie_break = _TIE_BREAK_MOVES[spec.step_tie_break]
    predicate = spec.match_predicate.model_dump()

    lines = [
        f"def {func_name}({a_var}: list[int], {b_var}: list[int]) -> int:",
        f"    template = {spec.template.value!r}",
        f"    output_mode = {spec.output_mode.value!r}",
        f"    predicate = {predicate!r}",
        f"    match_score = {spec.match_score}",
        f"    mismatch_score = {spec.mismatch_score}",
        f"    gap_score = {spec.gap_score}",
        f"    tie_order = {tie_break!r}",
        "    i64_mask = (1 << 64) - 1",
        "",
        "    def _wrap_i64(value: int) -> int:",
        "        wrapped = value & i64_mask",
        "        if wrapped >= (1 << 63):",
        "            return wrapped - (1 << 64)",
        "        return wrapped",
        "",
        "    def _unsigned_i64(value: int) -> int:",
        "        return value & i64_mask",
        "",
        "    def _matches(x: int, y: int) -> bool:",
        "        kind = predicate['kind']",
        "        if kind == 'eq':",
        "            return x == y",
        "        if kind == 'abs_diff_le':",
        "            if x >= y:",
        "                abs_diff = _wrap_i64(x - y)",
        "            else:",
        "                abs_diff = _wrap_i64(y - x)",
        (
            "            return _unsigned_i64(abs_diff) <= "
            "_unsigned_i64(predicate['max_diff'])"
        ),
        (
            "        return _wrap_i64(x - y) % predicate['divisor'] == "
            "predicate['remainder']"
        ),
        "",
        "    def _pick(diag, up, left):",
        "        options = {'diag': diag, 'up': up, 'left': left}",
        "        best_score = max(diag[0], up[0], left[0])",
        "        for move in tie_order:",
        "            candidate = options[move]",
        "            if candidate[0] == best_score:",
        "                return candidate",
        "        raise RuntimeError('unreachable tie-break state')",
        "",
        f"    n = len({a_var})",
        f"    m = len({b_var})",
        "    zero = (0, 0, 0)  # (score, alignment_len, gap_count)",
        "    dp = [[zero for _ in range(m + 1)] for _ in range(n + 1)]",
        "",
        "    if template == 'global':",
        "        for i in range(1, n + 1):",
        "            s, l, g = dp[i - 1][0]",
        "            dp[i][0] = (",
        "                _wrap_i64(s + gap_score),",
        "                _wrap_i64(l + 1),",
        "                _wrap_i64(g + 1),",
        "            )",
        "        for j in range(1, m + 1):",
        "            s, l, g = dp[0][j - 1]",
        "            dp[0][j] = (",
        "                _wrap_i64(s + gap_score),",
        "                _wrap_i64(l + 1),",
        "                _wrap_i64(g + 1),",
        "            )",
        "",
        "    best = zero",
        "    for i in range(1, n + 1):",
        "        for j in range(1, m + 1):",
        "            ai = i - 1",
        "            bj = j - 1",
        "            prev_s, prev_l, prev_g = dp[i - 1][j - 1]",
        "            delta = match_score if _matches(",
        f"                {a_var}[ai], {b_var}[bj]",
        "            ) else mismatch_score",
        "            diag = (",
        "                _wrap_i64(prev_s + delta),",
        "                _wrap_i64(prev_l + 1),",
        "                prev_g,",
        "            )",
        "",
        "            up_s, up_l, up_g = dp[i - 1][j]",
        "            up = (",
        "                _wrap_i64(up_s + gap_score),",
        "                _wrap_i64(up_l + 1),",
        "                _wrap_i64(up_g + 1),",
        "            )",
        "",
        "            left_s, left_l, left_g = dp[i][j - 1]",
        "            left = (",
        "                _wrap_i64(left_s + gap_score),",
        "                _wrap_i64(left_l + 1),",
        "                _wrap_i64(left_g + 1),",
        "            )",
        "",
        "            chosen = _pick(diag, up, left)",
        "            if template == 'local' and chosen[0] <= 0:",
        "                chosen = zero",
        "            dp[i][j] = chosen",
        "",
        "            if template == 'local' and chosen[0] > best[0]:",
        "                best = chosen",
        "",
        "    if template == 'global':",
        "        result = dp[n][m]",
        "    else:",
        "        result = best",
        "",
        "    if output_mode == 'score':",
        "        return result[0]",
        "    if output_mode == 'alignment_len':",
        "        return result[1]",
        "    return result[2]",
    ]
    return "\n".join(lines)
