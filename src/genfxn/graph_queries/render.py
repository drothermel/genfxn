from genfxn.graph_queries.models import GraphQueriesSpec


def render_graph_queries(
    spec: GraphQueriesSpec,
    func_name: str = "f",
    src_var: str = "src",
    dst_var: str = "dst",
) -> str:
    edges = [(edge.u, edge.v, edge.w) for edge in spec.edges]

    lines = [
        f"def {func_name}({src_var}: int, {dst_var}: int) -> int:",
        f"    n_nodes = {spec.n_nodes}",
        f"    directed = {spec.directed!r}",
        f"    weighted = {spec.weighted!r}",
        f"    query_type = {spec.query_type.value!r}",
        f"    edges = {edges!r}",
        "",
        f"    if type({src_var}) is not int:",
        f"        raise ValueError(('src must be int', {src_var}))",
        f"    if type({dst_var}) is not int:",
        f"        raise ValueError(('dst must be int', {dst_var}))",
        f"    if {src_var} < 0 or {src_var} >= n_nodes:",
        f"        raise ValueError(('src out of range', {src_var}))",
        f"    if {dst_var} < 0 or {dst_var} >= n_nodes:",
        f"        raise ValueError(('dst out of range', {dst_var}))",
        "",
        "    for i in range(len(edges)):",
        "        raw_u, raw_v, raw_w = edges[i]",
        "        if type(raw_u) is not int:",
        "            raise ValueError(('edge.u must be int', raw_u))",
        "        if raw_u < 0 or raw_u >= n_nodes:",
        "            raise ValueError(('edge.u out of range', raw_u))",
        "        if type(raw_v) is not int:",
        "            raise ValueError(('edge.v must be int', raw_v))",
        "        if raw_v < 0 or raw_v >= n_nodes:",
        "            raise ValueError(('edge.v out of range', raw_v))",
        "        if raw_w < 0:",
        "            raise ValueError(('edge.w must be >= 0', raw_w))",
        "",
        f"    if {src_var} == {dst_var}:",
        "        if query_type == 'reachable':",
        "            return 1",
        "        return 0",
        "",
        "    best: dict[tuple[int, int], int] = {}",
        "    for raw_u, raw_v, raw_w in edges:",
        "        weight = raw_w if weighted else 1",
        "        key = (raw_u, raw_v)",
        "        prev = best.get(key)",
        "        if prev is None or weight < prev:",
        "            best[key] = weight",
        "        if not directed:",
        "            rev_key = (raw_v, raw_u)",
        "            rev_prev = best.get(rev_key)",
        "            if rev_prev is None or weight < rev_prev:",
        "                best[rev_key] = weight",
        "",
        "    adjacency: dict[int, list[tuple[int, int]]] = {",
        "        node: [] for node in range(n_nodes)",
        "    }",
        "    for (u, v), weight in best.items():",
        "        adjacency[u].append((v, weight))",
        "    for neighbors in adjacency.values():",
        "        neighbors.sort()",
        "",
        "    if query_type == 'reachable':",
        "        visited = {" + src_var + "}",
        "        queue = [" + src_var + "]",
        "        head = 0",
        "        while head < len(queue):",
        "            node = queue[head]",
        "            head += 1",
        "            if node == " + dst_var + ":",
        "                return 1",
        "            for neighbor, _ in adjacency[node]:",
        "                if neighbor in visited:",
        "                    continue",
        "                visited.add(neighbor)",
        "                queue.append(neighbor)",
        "        return 0",
        "",
        "    if query_type == 'min_hops':",
        "        visited = {" + src_var + "}",
        "        queue = [(" + src_var + ", 0)]",
        "        head = 0",
        "        while head < len(queue):",
        "            node, hops = queue[head]",
        "            head += 1",
        "            if node == " + dst_var + ":",
        "                return hops",
        "            for neighbor, _ in adjacency[node]:",
        "                if neighbor in visited:",
        "                    continue",
        "                visited.add(neighbor)",
        "                queue.append((neighbor, hops + 1))",
        "        return -1",
        "",
        "    best_cost_prev = {" + src_var + ": 0}",
        "    for _ in range(n_nodes - 1):",
        "        changed = False",
        "        best_cost_curr = dict(best_cost_prev)",
        "        for node, neighbors in adjacency.items():",
        "            cost = best_cost_prev.get(node)",
        "            if cost is None:",
        "                continue",
        "            for neighbor, weight in neighbors:",
        "                if cost > ((1 << 63) - 1) - weight:",
        "                    next_cost = (1 << 63) - 1",
        "                else:",
        "                    next_cost = cost + weight",
        "                prev = best_cost_curr.get(neighbor)",
        "                if prev is not None and next_cost >= prev:",
        "                    continue",
        "                best_cost_curr[neighbor] = next_cost",
        "                changed = True",
        "        best_cost_prev = best_cost_curr",
        "        if not changed:",
        "            break",
        "    return best_cost_prev.get(" + dst_var + ", -1)",
    ]
    return "\n".join(lines)
