from genfxn.graph_queries.models import GraphQueriesSpec


def render_graph_queries(
    spec: GraphQueriesSpec,
    func_name: str = "f",
    src_var: str = "src",
    dst_var: str = "dst",
) -> str:
    edges = [(edge.u, edge.v, edge.w) for edge in spec.edges]

    lines = [
        f"def {func_name}({src_var}: int, {dst_var}: int) -> int:",
        f"    n_nodes = {spec.n_nodes}",
        f"    directed = {spec.directed!r}",
        f"    weighted = {spec.weighted!r}",
        f"    query_type = {spec.query_type.value!r}",
        f"    edges = {edges!r}",
        "",
        f"    if {src_var} < 0 or {src_var} >= n_nodes:",
        f"        raise ValueError('src out of range: {src_var}')",
        f"    if {dst_var} < 0 or {dst_var} >= n_nodes:",
        f"        raise ValueError('dst out of range: {dst_var}')",
        "",
        f"    if {src_var} == {dst_var}:",
        "        if query_type == 'reachable':",
        "            return 1",
        "        return 0",
        "",
        "    best: dict[tuple[int, int], int] = {}",
        "    for raw_u, raw_v, raw_w in edges:",
        "        weight = raw_w if weighted else 1",
        "        key = (raw_u, raw_v)",
        "        prev = best.get(key)",
        "        if prev is None or weight < prev:",
        "            best[key] = weight",
        "        if not directed:",
        "            rev_key = (raw_v, raw_u)",
        "            rev_prev = best.get(rev_key)",
        "            if rev_prev is None or weight < rev_prev:",
        "                best[rev_key] = weight",
        "",
        "    adjacency: dict[int, list[tuple[int, int]]] = {",
        "        node: [] for node in range(n_nodes)",
        "    }",
        "    for (u, v), weight in best.items():",
        "        adjacency[u].append((v, weight))",
        "    for neighbors in adjacency.values():",
        "        neighbors.sort()",
        "",
        "    if query_type == 'reachable':",
        "        visited = {" + src_var + "}",
        "        queue = [" + src_var + "]",
        "        head = 0",
        "        while head < len(queue):",
        "            node = queue[head]",
        "            head += 1",
        "            if node == " + dst_var + ":",
        "                return 1",
        "            for neighbor, _ in adjacency[node]:",
        "                if neighbor in visited:",
        "                    continue",
        "                visited.add(neighbor)",
        "                queue.append(neighbor)",
        "        return 0",
        "",
        "    if query_type == 'min_hops':",
        "        visited = {" + src_var + "}",
        "        queue = [(" + src_var + ", 0)]",
        "        head = 0",
        "        while head < len(queue):",
        "            node, hops = queue[head]",
        "            head += 1",
        "            if node == " + dst_var + ":",
        "                return hops",
        "            for neighbor, _ in adjacency[node]:",
        "                if neighbor in visited:",
        "                    continue",
        "                visited.add(neighbor)",
        "                queue.append((neighbor, hops + 1))",
        "        return -1",
        "",
        "    best_cost = {" + src_var + ": 0}",
        "    frontier = [" + src_var + "]",
        "    while frontier:",
        "        best_idx = 0",
        "        best_node = frontier[0]",
        "        best_pair = (best_cost[best_node], best_node)",
        "        for i in range(1, len(frontier)):",
        "            candidate_node = frontier[i]",
        "            candidate_pair = (",
        "                best_cost[candidate_node],",
        "                candidate_node,",
        "            )",
        "            if candidate_pair < best_pair:",
        "                best_pair = candidate_pair",
        "                best_idx = i",
        "",
        "        node = frontier[best_idx]",
        "        cost = best_cost[node]",
        "        frontier[best_idx] = frontier[-1]",
        "        frontier.pop()",
        "        if node == " + dst_var + ":",
        "            return cost",
        "        for neighbor, weight in adjacency[node]:",
        "            next_cost = cost + weight",
        "            prev = best_cost.get(neighbor)",
        "            if prev is not None and next_cost >= prev:",
        "                continue",
        "            best_cost[neighbor] = next_cost",
        "            if prev is None:",
        "                frontier.append(neighbor)",
        "    return -1",
    ]
    return "\n".join(lines)
