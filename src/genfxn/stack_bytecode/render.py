from genfxn.stack_bytecode.models import StackBytecodeSpec


def _render_program(spec: StackBytecodeSpec) -> str:
    lines = ["    program = ["]
    for instr in spec.program:
        lines.append(
            "        "
            + repr(
                {
                    "op": instr.op.value,
                    "value": instr.value,
                    "index": instr.index,
                    "target": instr.target,
                }
            )
            + ","
        )
    lines.append("    ]")
    return "\n".join(lines)


def render_stack_bytecode(
    spec: StackBytecodeSpec, func_name: str = "f", var: str = "xs"
) -> str:
    lines = [
        f"def {func_name}({var}: list[int]) -> tuple[int, int]:",
        "    # Runtime status: 0=ok, 1=step_limit, 2=stack_underflow,",
        "    # 3=bad_jump_target, 4=div_or_mod_by_zero,",
        "    # 5=invalid_input_index, 6=empty_stack_on_halt",
    ]
    lines.extend(_render_program(spec).splitlines())
    lines.extend(
        [
            "    max_step_count = " + str(spec.max_step_count),
            "    jump_target_mode = " + repr(spec.jump_target_mode.value),
            "    input_mode = " + repr(spec.input_mode.value),
            "    i64_mask = (1 << 64) - 1",
            "    i64_min = -(1 << 63)",
            "",
            "    def wrap_i64(value: int) -> int:",
            "        wrapped = value & i64_mask",
            "        if wrapped >= (1 << 63):",
            "            return wrapped - (1 << 64)",
            "        return wrapped",
            "",
            "    def div_trunc_zero(a: int, b: int) -> int:",
            "        sign = -1 if (a < 0) ^ (b < 0) else 1",
            "        if a == i64_min and b == -1:",
            "            return i64_min",
            "        return wrap_i64(sign * (abs(a) // abs(b)))",
            "",
            "    def mod_trunc_zero(a: int, b: int) -> int:",
            "        if a == i64_min and b == -1:",
            "            return 0",
            "        return wrap_i64(a - div_trunc_zero(a, b) * b)",
            "",
            "    def normalize_target(target: int) -> int | None:",
            "        n = len(program)",
            "        if jump_target_mode == 'error':",
            "            if 0 <= target < n:",
            "                return target",
            "            return None",
            "        if jump_target_mode == 'clamp':",
            "            if target < 0:",
            "                return 0",
            "            if target >= n:",
            "                return n - 1",
            "            return target",
            "        return target % n",
            "",
            "    stack: list[int] = []",
            "    pc = 0",
            "    steps = 0",
            "    n = len(program)",
            "",
            "    while steps < max_step_count:",
            "        if not (0 <= pc < n):",
            "            return (3, 0)",
            "",
            "        instr = program[pc]",
            "        op = instr['op']",
            "        steps += 1",
            "",
            "        if op == 'push_const':",
            "            stack.append(wrap_i64(instr['value']))",
            "            pc += 1",
            "            continue",
            "",
            "        if op == 'load_input':",
            "            idx = instr['index']",
            "            if input_mode == 'direct':",
            "                if idx < 0 or idx >= len(" + var + "):",
            "                    return (5, 0)",
            "                stack.append(wrap_i64(" + var + "[idx]))",
            "            else:",
            "                if len(" + var + ") == 0:",
            "                    return (5, 0)",
            "                stack.append(",
            (
                "                    wrap_i64("
                + var
                + "[idx % len("
                + var
                + ")]),"
            ),
            "                )",
            "            pc += 1",
            "            continue",
            "",
            "        if op == 'dup':",
            "            if not stack:",
            "                return (2, 0)",
            "            a = stack.pop()",
            "            stack.append(a)",
            "            stack.append(a)",
            "            pc += 1",
            "            continue",
            "",
            "        if op == 'swap':",
            "            if len(stack) < 2:",
            "                return (2, 0)",
            "            b = stack.pop()",
            "            a = stack.pop()",
            "            stack.append(b)",
            "            stack.append(a)",
            "            pc += 1",
            "            continue",
            "",
            "        if op == 'pop':",
            "            if not stack:",
            "                return (2, 0)",
            "            stack.pop()",
            "            pc += 1",
            "            continue",
            "",
            "        if op in (",
            "            'add', 'sub', 'mul', 'div',",
            "            'mod', 'eq', 'gt', 'lt'",
            "        ):",
            "            if len(stack) < 2:",
            "                return (2, 0)",
            "            b = stack.pop()",
            "            a = stack.pop()",
            "            if op == 'add':",
            "                stack.append(wrap_i64(a + b))",
            "            elif op == 'sub':",
            "                stack.append(wrap_i64(a - b))",
            "            elif op == 'mul':",
            "                stack.append(wrap_i64(a * b))",
            "            elif op == 'div':",
            "                if b == 0:",
            "                    return (4, 0)",
            "                stack.append(div_trunc_zero(a, b))",
            "            elif op == 'mod':",
            "                if b == 0:",
            "                    return (4, 0)",
            "                stack.append(mod_trunc_zero(a, b))",
            "            elif op == 'eq':",
            "                stack.append(1 if a == b else 0)",
            "            elif op == 'gt':",
            "                stack.append(1 if a > b else 0)",
            "            else:",
            "                stack.append(1 if a < b else 0)",
            "            pc += 1",
            "            continue",
            "",
            "        if op == 'neg':",
            "            if not stack:",
            "                return (2, 0)",
            "            stack.append(wrap_i64(-stack.pop()))",
            "            pc += 1",
            "            continue",
            "",
            "        if op == 'abs':",
            "            if not stack:",
            "                return (2, 0)",
            "            stack.append(wrap_i64(abs(stack.pop())))",
            "            pc += 1",
            "            continue",
            "",
            "        if op == 'is_zero':",
            "            if not stack:",
            "                return (2, 0)",
            "            a = stack.pop()",
            "            stack.append(1 if a == 0 else 0)",
            "            pc += 1",
            "            continue",
            "",
            "        if op in ('jump', 'jump_if_zero', 'jump_if_nonzero'):",
            "            target = instr['target']",
            "            if op == 'jump':",
            "                cond = True",
            "            else:",
            "                if not stack:",
            "                    return (2, 0)",
            "                a = stack.pop()",
            "                cond = (",
            "                    (a == 0)",
            "                    if op == 'jump_if_zero'",
            "                    else (a != 0)",
            "                )",
            "            if cond:",
            "                resolved = normalize_target(target)",
            "                if resolved is None:",
            "                    return (3, 0)",
            "                pc = resolved",
            "            else:",
            "                pc += 1",
            "            continue",
            "",
            "        if op == 'halt':",
            "            if not stack:",
            "                return (6, 0)",
            "            return (0, stack[-1])",
            "",
            "        return (3, 0)",
            "",
            "    return (1, 0)",
        ]
    )
    return "\n".join(lines)
